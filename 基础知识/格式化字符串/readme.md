## 格式化字符串漏洞利用

### 0x001-格式化字符串漏洞任意地址读取

![](1.png)

> %x : 以十六进制形式打印栈中 **数据A** 的值

> %d : 以十进制形式打印栈中 **数据A** 的值

> %p : 以指针形式（十六进制）打印栈中 **数据A** 的值

> %s : 以字符串形式打印栈中 **数据B** 的值

通过 **%n\$x** 可以打印栈中任意位置 **数据A** 的值，或者通过 **%n\$s** 可以打印栈中任意位置 **数据B** 的值，n为偏移量控制栈的位置，一般 n>=1。

也可以使用 **地址+%n$s** 打印任意地址中保存的内容，此时 **n** 为输入内容相对于 **printf** 的偏移量。

### 0x002-格式化字符串漏洞任意地址写入

> %c : 输出字符，可以配合 **%n** 使用

> %n : 把已经成功输出的字符个数写入对应的整型指针参数所指的变量中

例如，可以使用 **p32(0x804c044) + b"%10$n"**，将 4 写入 **0x804c044** 中，因为 **p32(0x804c044)** 打印出来是4个字符；

也可以使用 **p32(atoi_got) + b"%" + str(system_plt-4).encode() + b"c%10$n"** 将 **atoi** 函数的GOT地址修改为 **system** 函数的PLT地址****。

pwntools提供了格式化字符串漏洞利用的函数如下：
```
payload = fmtstr_payload(offset, {atoi_got:system_plt})
```

该函数可将atoi_got地址值改为system_plt。

### 0x003-格式化字符串漏洞未解之疑惑

在使用任意地址写入时，可以将要写入内容的地址放在前面，也可以将该地址放在后面，还没弄明白这两者的区别，有待解决。